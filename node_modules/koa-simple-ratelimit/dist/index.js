"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ratelimit = void 0;
const debug_1 = __importDefault(require("debug"));
const ms_1 = __importDefault(require("ms"));
const debug = debug_1.default('koa-simple-ratelimit');
async function find(db, p) {
    return new Promise((resolve, reject) => {
        db.get(p, (err, reply) => {
            if (err) {
                reject(err);
            }
            resolve(reply);
        });
    });
}
async function pttl(db, p) {
    return new Promise((resolve, reject) => {
        db.pttl(p, (err, reply) => {
            if (err) {
                reject(err);
            }
            resolve(reply);
        });
    });
}
/**
 * Initialize ratelimit middleware with the given `opts`
 */
function ratelimit(options) {
    const opts = {
        max: 2500,
        duration: 3600000,
        throw: false,
        prefix: 'limit',
        id: (ctx) => ctx.ip,
        allowlist: [],
        blocklist: [],
        headers: {
            remaining: 'X-RateLimit-Remaining',
            reset: 'X-RateLimit-Reset',
            total: 'X-RateLimit-Limit',
        },
        errorMessage: (exp) => `Rate limit exceeded, retry in ${ms_1.default(exp, { long: true })}.`,
        ...options,
    };
    const { remaining = 'X-RateLimit-Remaining', reset = 'X-RateLimit-Reset', total = 'X-RateLimit-Limit', } = opts.headers || {};
    // eslint-disable-next-line func-names
    return async function rateLimitMiddleware(ctx, next) {
        var _a, _b;
        const id = opts.id(ctx);
        if (id === false) {
            return next();
        }
        if ((_a = opts.allowlist) === null || _a === void 0 ? void 0 : _a.includes(id)) {
            return next();
        }
        if ((_b = opts.blocklist) === null || _b === void 0 ? void 0 : _b.includes(id)) {
            return ctx.throw(403);
        }
        const prefix = opts.prefix ? opts.prefix : 'limit';
        const name = `${prefix}:${id}:count`;
        const cur = await find(opts.db, name);
        const n = Math.floor(Number(cur));
        let t = Date.now();
        t += opts.duration;
        t = Math.floor(new Date(t).getTime() / 1000) || 0;
        const headers = {
            [remaining]: opts.max - 1,
            [reset]: t,
            [total]: opts.max,
        };
        ctx.set(headers);
        // Not existing in redis
        if (cur === null) {
            opts.db.set(name, opts.max - 1, 'PX', opts.duration, 'NX');
            debug('remaining %s/%s %s', opts.max - 1, opts.max, id);
            return next();
        }
        const expires = await pttl(opts.db, name);
        if (n - 1 >= 0) {
            // Existing in redis
            opts.db.decr(name);
            ctx.set(remaining, n - 1);
            debug('remaining %s/%s %s', n - 1, opts.max, id);
            return next();
        }
        if (expires < 0) {
            debug(`${name} is stuck. Resetting.`);
            opts.db.set(name, opts.max - 1, 'PX', opts.duration, 'NX');
            return next();
        }
        // User maxed
        debug('remaining %s/%s %s', remaining, opts.max, id);
        ctx.set(remaining, n);
        ctx.set('Retry-After', t);
        ctx.status = 429;
        if (typeof opts.errorMessage === 'function') {
            ctx.body = opts.errorMessage(expires);
        }
        else {
            ctx.body = opts.errorMessage;
        }
        if (opts.throw) {
            ctx.throw(ctx.status, ctx.body, { headers });
        }
    };
}
exports.ratelimit = ratelimit;
